#load "draw.zen";

namespace game;

struct Tile
{
	Entity* entity;
}

const int MAP_WIDTH  = 12;
const int MAP_HEIGHT = 6;

// 12 * 6
let Tile[72] map_tiles;

let	Player player;
let	Crate testCrate;

fun void map_load()
{
    // @TODO arrays should be initialized to their default values by default.
	for (let int i = 0; i < MAP_WIDTH * MAP_HEIGHT; i += 1)
	{
		// map_tiles[i].active = false;
		map_tiles[i].entity = null;
	}

	player_init(&player);
	map_move_entity(&testCrate.entity, 4, 2);
}

fun void map_draw()
{
	for (let int y = 0; y < MAP_WIDTH; y += 1)
	{
		for (let int x = 0; x < MAP_HEIGHT; x += 1)
		{
			let Tile tile = map_tiles[y * MAP_HEIGHT + x];

/*
			var raylib::Color tileColor; tileColor.a = 255;
			if (tile.active == true)
			{
				tileColor.r = 255;
			}

			if (tile.active == true)
			{
				raylib::DrawRectangle(x * CELL_WIDTH, y * CELL_HEIGHT, CELL_WIDTH, CELL_HEIGHT, tileColor);
			}
			*/
		}
	}

	draw_rect_lines(0.0, 0.0, cast(float)(MAP_WIDTH * CELL_WIDTH), cast(float)(MAP_HEIGHT * CELL_HEIGHT), raylib::LightGray);

	crate_draw(&testCrate);
	player_draw(&player);
}

fun void map_update()
{
	entity_update(&testCrate.entity);
	player_update(&player);
}

fun void map_move_entity(Entity* e, int dx, int dy)
{
	if (dx == 0 && dy == 0)
	{
		// We didn't move lol
		return;
	}
	if (e == null)
	{
		return;
	}

	let int nx = e.x + dx;
	let int ny = e.y + dy;

	// @TODO
	// Array indexing OOB is undefined behavior in C,
	// meaning it can crash on TinyCC, but appear to work in MSVC, or vice versa...
	// That's not good! So we'll want to use our own array type or potentially emit some macro that does bounds checking for us.
	// Basically, we want to omit as much UB as possible.
	let Entity* destE = map_tiles[nx + (ny * MAP_WIDTH)].entity;
	if (destE != null)
	{
		if (e.player == true)
		{
			map_move_entity(destE, dx, dy);
		}
	}

	map_tiles[e.x + (e.y * MAP_WIDTH)].entity = null;
	map_tiles[nx + (ny * MAP_WIDTH)].entity = e;

	e.x = nx;
	e.y = ny;
}