#load "draw.zen";

namespace game;

struct Tile
{
	Entity* entity;
}

const int MAP_WIDTH  = 12;
const int MAP_HEIGHT = 6;

// 12 * 6
let Tile[72] map_tiles;

let	Player player;
let	Crate testCrate;

fun void map_load()
{
    // @TODO arrays should be initialized to their default values by default.
	for (let int i = 0; i < MAP_WIDTH * MAP_HEIGHT; i += 1)
	{
		// map_tiles[i].active = false;
		map_tiles[i].entity = null;
	}

	player_init(&player);
	map_move_entity(&testCrate.entity, 4, 2);

	/*
	for (let int i = 0; LEVEL[i] != '\0'; i += 1)
	{

	}
	*/
}

fun void map_draw()
{
	const raylib::Color checker1 = { 0, 0, 0, 15 };
	const raylib::Color checker2 = { 21, 24, 31, 28 };

	for (let int y = 0; y < MAP_HEIGHT; y += 1)
	{
		for (let int x = 0; x < MAP_WIDTH; x += 1)
		{
			let Tile tile = map_tiles[y * MAP_HEIGHT + x];

			var raylib::Color tileColor = checker1;

			if ((x - y) % 2 == 0)
			{
				tileColor = checker2;
			}

			raylib::DrawRectangle(x * CELL_WIDTH, y * CELL_HEIGHT, CELL_WIDTH, CELL_HEIGHT, tileColor);
		}
	}

	draw_rect_lines(0.0, 0.0, cast(float)(MAP_WIDTH * CELL_WIDTH), cast(float)(MAP_HEIGHT * CELL_HEIGHT), raylib::LightGray);

	crate_draw(&testCrate);
	player_draw(&player);

	#c { printf("hello world!"); }
}

fun void map_update()
{
	entity_update(&testCrate.entity);
	player_update(&player);
}

fun void map_move_entity(Entity* e, int dx, int dy)
{
	if (dx == 0 && dy == 0)
	{
		// We didn't move lol
		return;
	}
	if (e == null)
	{
		return;
	}

	let int nx = e.x + dx;
	let int ny = e.y + dy;

	// @TODO
	// Array indexing OOB is undefined behavior in C,
	// meaning it can crash on TinyCC, but appear to work in MSVC, or vice versa...
	// That's not good! So we'll want to use our own array type or potentially emit some macro that does bounds checking for us.
	// Basically, we want to omit as much UB as possible.
	let Entity* destE = map_tiles[nx + (ny * MAP_WIDTH)].entity;
	if (destE != null)
	{
		if (e.player == true)
		{
			map_move_entity(destE, dx, dy);
		}
	}

	map_tiles[e.x + (e.y * MAP_WIDTH)].entity = null;
	map_tiles[nx + (ny * MAP_WIDTH)].entity = e;

	e.x = nx;
	e.y = ny;
}

fun bool map_add_entity(Entity* e)
{
	if (e == null)
	{
		return false;
	}

	map_tiles[e.x + e.y * MAP_WIDTH].entity = e;

	return true;
}