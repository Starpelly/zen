#load "draw.zen";

namespace game;

struct Tile
{
	Entity* entity;
}

const int MAP_WIDTH  = 12;
const int MAP_HEIGHT = 6;

const int MAX_ENTITIES = 32;

// 12 * 6
let Tile[72] map_tiles;
let Entity*[MAX_ENTITIES] entities;

let	Player player;
let	Crate testCrate;
let	Crate testCrate2;

fun void map_load()
{
    // @TODO arrays should be initialized to their default values by default.
	for (let int i = 0; i < MAP_WIDTH * MAP_HEIGHT; i += 1)
	{
		// map_tiles[i].active = false;
		map_tiles[i].entity = null;
	}

	player_init(&player);
	map_move_entity(&testCrate.entity, 4, 2);
	map_move_entity(&testCrate2.entity, 4, 4);

/*
	#c {
		// printf("%s\n", "Hello from C!");

		int x = 0;
		int y = 0;
		for (int i = 0; zen_game_LEVEL[i] != '\0'; i++)
		{
			if (zen_game_LEVEL[i] == '\n')
			{
				x = 0;
				y += 1;
			}
			else
			{
				switch (zen_game_LEVEL[i])
				{
					case '@':
					{
						zen_game_player.entity.x = x;
						zen_game_player.entity.y = y;
						break;
					}
					case 'c':
					{
						// zen_game_Crate* crate = (zen_game_Crate*)malloc(sizeof(zen_game_Crate));
						// zen_game_map_add_entity(crate);
						break;
					}
				}
			}

			x += 1;
		}
	};
*/
	/*
	for (let int i = 0; LEVEL[i] != '\0'; i += 1)
	{

	}
	*/
}

fun void map_draw()
{
	const raylib::Color checker1 = { 0, 0, 0, 15 };
	const raylib::Color checker2 = { 21, 24, 31, 28 };

	for (let int y = 0; y < MAP_HEIGHT; y += 1)
	{
		for (let int x = 0; x < MAP_WIDTH; x += 1)
		{
			let Tile tile = map_tiles[y * MAP_HEIGHT + x];

			var raylib::Color tileColor = checker1;

			if ((x - y) % 2 == 0)
			{
				tileColor = checker2;
			}

			raylib::DrawRectangle(x * CELL_WIDTH, y * CELL_HEIGHT, CELL_WIDTH, CELL_HEIGHT, tileColor);
		}
	}

	draw_rect_lines(0.0, 0.0, cast(float)(MAP_WIDTH * CELL_WIDTH), cast(float)(MAP_HEIGHT * CELL_HEIGHT), raylib::LightGray);

	crate_draw(&testCrate);
	crate_draw(&testCrate2);
	player_draw(&player);
}

fun void map_update()
{
	entity_update(&testCrate.entity);
	entity_update(&testCrate2.entity);
	player_update(&player);
}

fun void map_move_entity(Entity* e, int dx, int dy)
{
	if (dx == 0 && dy == 0)
	{
		// We didn't move lol
		return;
	}
	if (e == null)
	{
		return;
	}

	let int nx = e.x + dx;
	let int ny = e.y + dy;

	// @TODO
	// Array indexing OOB is undefined behavior in C,
	// meaning it can crash on TinyCC, but appear to work in MSVC, or vice versa...
	// That's not good! So we'll want to use our own array type or potentially emit some macro that does bounds checking for us.
	// Basically, we want to omit as much UB as possible.
	let Entity* destE = map_tiles[nx + (ny * MAP_WIDTH)].entity;
	if (destE != null)
	{
			map_move_entity(destE, dx, dy);

	}

	map_tiles[e.x + (e.y * MAP_WIDTH)].entity = null;
	map_tiles[nx + (ny * MAP_WIDTH)].entity = e;

	e.x = nx;
	e.y = ny;
}

fun bool map_add_entity(Entity* e)
{
	if (e == null)
	{
		return false;
	}

	map_tiles[e.x + e.y * MAP_WIDTH].entity = e;

	return true;
}